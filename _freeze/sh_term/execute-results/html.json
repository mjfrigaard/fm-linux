{
  "hash": "283f1bca6847b069795a24f3c3bbd6bb",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n\n\n\n# Shells and Terminals {#sec-sh-term}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is under development. Thank you for your patience.\n  \n\n::: \n\n::::\n\n\n\n\n\nIn Unix/Linux environments, the terms \"Shell\" and \"Terminal\" are commonly used and although they are related, they actually refer to different things: \n\n:::: {layout=\"[50,50]\" layout-valign=\"top\"}\n\n[A **Shell** in Unix/Linux is a program that interprets commands and acts as an intermediary between the user and the kernel of the operating system.]{style=\"font-size: 0.95em;\"}\n\n[A **Terminal** (or terminal emulator) is a software program that provides a text-based interface to the shell. The sections below cover common Shells and Terminals.]{style=\"font-size: 0.95em;\"}\n\n::::\n\n## [Shells]{style=\"font-size: 1.15em; font-weight: bold;\"} {#sec-shells}\n\nThe shell processes user commands, which might involve calling other programs, and returns the output to the user. Shells can be either command-line based or graphical. Some popular examples of shells include Bash, Zsh, and Fish.\n\nYou can use the <strong><code>@sec-echo</code></strong> and <strong><code>@sec-ps</code></strong> commands to discover which shell you're currently using:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho $SHELL\n# /bin/zsh\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nps -p $$\n#   PID TTY           TIME CMD\n#   683 ttys000    0:00.09 -zsh\n```\n:::\n\n\n:::: {.callout-tip collapse='true' appearance='default' icon=false}\n\n## [Tip]{style='font-weight: bold; font-size: 1.10em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nAs we can see from the outupt above, I'm currently using the Zsh shell. I'll use a green callout box to indicate the programs or tools I'm using.\n\n::: \n\n::::\n\n\n\n\n\n### ![](img/bash-logo.svg){fig-align=\"right\" width=\"12%\"} Bash {#sec-bash}\n\nIntroduced in 1989, [**Bash, or the Bourne Again SHell**](https://www.gnu.org/software/bash/) has become the default command-line interface or shell for most Linux distributions. Incorporating features from the Korn shell ([`ksh`](https://en.wikipedia.org/wiki/KornShell)) and the C shell ([`csh`](https://en.wikipedia.org/wiki/C_shell)), Bash supports features like command history, tab completion, aliases and scripting tasks.[^bash-macos] \n\n[^bash-macos]: Bash was the default command-line interface for Apple's macOS (which is Unix-based) until the transition to `zsh` as the default shell in [macOS Catalina.](https://support.apple.com/en-us/102360)\n\n::: {.callout-note collapse=\"true\"}\n\n#### [Key features of ![](img/bash-logo.svg){width=\"8%\"} Bash]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n\n**Programming Features**\n\nBash includes an array of programming constructs that make it a powerful tool for scripting, which includes:  \n-   Conditional statements (`if`, `then`, `else`, `elif`, `fi`)\n-   Looping statements (`for`, `while`, `until`)\n-   Functions that allow code reusability\n\n**Command Line Editing**\n\nBash provides an interactive command line editing environment with features: \n\n-   History expansion: Commands can be re-executed by recalling them from the history\n-   Command line editing: Users can navigate and edit commands directly on the command line using Emacs or Vi editing modes\n-   Tab Completion: Bash supports tab completion for command names, file names, and even command arguments, speeding up the input process and reducing typos\n\n**Job Control**\n\nBash offers comprehensive job control, which includes:  \n\n-   Backgrounding (`&`), foregrounding (`fg`), and job management (`jobs`, `bg`)   \n-   Stopping (suspending) processes and continuing them with `kill` and `kill -CONT`\n\n**Aliases and Shell Functions**\n\nUsers can create shorter commands to represent longer sequences of commands using aliases. Bash also supports more powerful functions that can take arguments like small scripts. \n\n**Redirection and Piping**\n\nBash allows for advanced redirection and piping: \n\n-   Redirecting input and output (`>`, `<`, `>>`, `2>`, etc.)\n-   Piping commands (`|`) are used to pass the output of one command as input to another\n\n**Script Debugging**\n\nBash scripts can be debugged using options like `set -x` to print commands and their arguments as they are executed, which is invaluable for troubleshooting scripts\n\n**Environment Control** \n\nBash allows users to control their shell environment extensively through:  \n\n-   Environment variables configuration and management\n-   Variables are exported to make them available to sub-processes\n\n**Expansion Capabilities**\n\nBash supports several types of expansions that enhance its scripting capabilities: \n\n-   Brace expansion: `{a,b,c}` \n-   Tilde expansion: `~` translates to the home directory. \n-   Parameter and variable expansion: `$name` or `${name}` \n-   Arithmetic expansion: `$(( expression )0`\n\n**History Features**\n\nBash maintains a history of commands that users have executed, which can be navigated, searched, and reused. It also supports configuring the history size and behavior through various environment variables like `HISTSIZE` and `HISTFILESIZE`.\n\n:::\n\n:::\n\n### ![](img/zshell-logo.png){fig-align=\"right\" width=\"12%\"} Zsh\n\n[**Zsh (Z Shell or 'Oh My ZSH!')**](https://ohmyz.sh/) is noted for its interactive features and is often used with customization frameworks. Zsh is a powerful command-line interpreter for Unix systems that serves as both a scriptable shell and an interactive command interpreter.[^zsh-bash]\n\n\n[^zsh-bash]: Zsh is an [extended version](https://en.wikipedia.org/wiki/Z_shell) of **Bash (Bourne Again SHell)**, with many improvements, and is fully compatible with the Bourne Shell.\n\n::: {.callout-tip collapse=\"true\"}\n#### [Key features of ![](img/zshell-logo.png){width=\"8%\"} Zsh]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n\n**Command Line Editing**\n\nZsh provides an advanced and customizable command-line editing environment. Users can configure key bindings and have extensive control over the text editing capabilities directly within the command prompt.\n\n**Tab Completion**\n\nZsh has one of the most powerful tab completion systems. It supports:\n\n-   Completion for command options and arguments.\n-   Automatic listing of options when a tab is hit twice.\n-   Context-sensitive completion that can recognize patterns in filenames, history, running processes, hostnames, and more.\n\n**Themes and Prompts**\n\nZsh allows extensive customization of its prompt, supporting themes that can completely change the look of your command line. The prompt can include colors, content from shell variables, functions, and command outputs.\n\n**Scripting**\n\nZsh scripting is robust, with features like arrays, associative arrays, and floating-point arithmetic which are not typically available in all shells. It enhances scripting capabilities and improves on the scripting syntax of the Bourne Shell.\n\n**Loadable Modules**: Zsh supports dynamically loadable modules, expanding its capabilities with features like:\n\n-   FTP client\n-   TCP and UDP socket operations\n-   Advanced math functions\n-   Full-fledged regular expression matching\n\n**Improved Variable Handling** \n\nVariable handling in Zsh includes several enhancements like:\n\n-   Better array handling\n-   Associative arrays (similar to dictionaries in higher-level programming languages)\n-   Easier string manipulation and pattern matching\n\n**Spell Check and Correction** \n\nZsh can be configured to correct commands automatically if misspelled and to suggest corrections or alternatives. This feature helps in reducing syntax errors and improves user efficiency.\n\n**Extended Globbing**\n\nZsh's file globbing allows for more complex pattern matching than traditional Unix shells. You can specify patterns in a more expressive and powerful way, which is particularly useful in scripts.\n\n:::\n:::\n\n### ![](img/fish-logo.png){fig-align=\"right\" width=\"12%\"} Fish\n\n[**Fish, or the Friendly Interactive SHell**](https://fishshell.com/), is a smart and user-friendly command line shell for Unix-like operating systems. It's designed to be more interactive and user-friendly than traditional shells like Bash or Zsh.[^fish-ars-technica]\n\n[^fish-ars-technica]: Ars Technica has a great [summary](https://arstechnica.com/information-technology/2005/12/linux-20051218/) comparing Fish to other shells.\n\n::: {.callout-note collapse=\"true\"}\n#### [Key features of ![](img/fish-small-logo.png){fig-align=\"right\" width=\"10%\"} Fish]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n\n**Autosuggestions** \n\nFish suggests commands as you type based on history and completions, just like a web browser. This feature allows users to see and reuse previous commands by simply pressing the right arrow key to complete the suggested command, which can significantly speed up typing and reduce errors.\n\n**Syntax Highlighting** \n\nOne of Fish's most noticeable features is its real-time syntax highlighting. Commands that are valid change color as you type them. It also helps users catch errors before the command is executed, such as highlighting misspelled commands or incorrect paths in red.\n\n**Web-Based Configuration** \n\nFish includes a web-based configuration interface (accessible via the `fish_config` command), which makes customizing the shell settings and prompt easier for users who prefer a graphical interface over editing configuration files manually (or if you're new to the command line).\n\n**Enhanced Tab Completion** \n\nFish provides intelligent tab completions for commands, file names, variables, and user-defined functions. It not only completes based on the prefix but also considers the whole line context, making the completions more relevant.\n\n**Improved Variables and Scoping** \n\nFish simplifies variable management, including universal variables that are automatically shared between all running shells and persist across restarts without needing explicit saving to a file. Variable scoping is also more straightforward, helping avoid common bugs seen in other shells.\n\n**Function Autoloads** \n\nFish allows functions to be defined in individual files and automatically loads them only when needed. This lazy-loading of functions helps speed up the start time of the shell.\n\n**Extensible** \n\nFish is designed to be easily extensible through plugins. The Fisherman and Oh My Fish frameworks offer many plugins and themes designed to enhance Fish's capabilities or customize its appearance.\n\n**Man Page Completions**\n\nFish generates command completions automatically from `man` pages, which means it often supports completions for all the installed commands without needing special configuration.\n\n**No Configuration Needed**\n\nFish is designed to work properly out of the box, without needing to configure it extensively. This makes it very accessible for new users or those who want a powerful shell without the need to customize or configure it heavily.\n\n**User-Friendly Scripts** \n\nFish uses a syntax that is slightly different from the traditional POSIX shell syntax, which is often simpler and easier to understand. For example, loops and conditionals are clearer, and there is no need for explicit subshell management.\n\n\n:::\n:::\n\n## [Terminals]{style=\"font-size: 1.15em; font-weight: bold;\"} {#sec-terminals}\n\nTerminals interpret keystrokes and commands from users and send these to the shell for execution. When the shell produces output, the terminal displays it to the user. **Terminal emulators** allow users to interact with the shell and other command-line tools. Below is an expanded look at some commonly used terminal emulators and their key features.\n\n### ![](img/gnome-logo.png){fig-align=\"right\" width=\"12%\"} GNOME\n\n[GNOME Terminal](https://help.gnome.org/users/gnome-terminal/stable/) is the default terminal emulator for the GNOME desktop environment, widely used in many Linux distributions.\n\n::: {.callout-note collapse=\"true\"}\n#### [Key features of GNOME]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n-   **Profiles**: Users can create multiple profiles, each with its own set of preferences, including colors, fonts, and keyboard shortcuts.\n\n-   **Tabs and Splitting**: Supports opening multiple tabs and can split the terminal window into multiple panes.\n\n-   **Transparency and Backgrounds**: Allows setting background images and adjusting the transparency of the terminal window.\n\n-   **Compatibility**: Supports UTF-8 for a wide range of characters, making it suitable for international use.\n:::\n:::\n\n### ![](img/konsole-logo.jpeg){fig-align=\"right\" width=\"12%\"} Konsole\n\n[Konsole](https://konsole.kde.org/) is part of the KDE desktop environment. It is known for its deep integration with KDE and its high degree of customizability.\n\n::: {.callout-note collapse=\"true\"}\n#### [Key features of Konsole]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n-   **Tabbed Interface**: Allows multiple tabs within a single window, facilitating multitasking.\n\n-   **Profiles**: Supports multiple profiles, enabling different settings for each session.\n\n-   **Split Views**: Users can split Konsole windows horizontally or vertically.\n\n-   **Transparency and Theming**: Supports background transparency and themes, which can be customized easily.\n:::\n:::\n\n### ![](img/iterm2-logo.png){fig-align=\"right\" width=\"12%\"} iTerm2\n\n[iTerm2](https://iterm2.com/) is a replacement for Terminal and the successor to iTerm for macOS. It offers features beyond what traditional terminals provide.\n\n::: {.callout-tip collapse=\"true\"}\n#### [Key features of iTerm2]{style=\"font-size: 1.15em;\"}\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\n-   **Split Panes**: Users can divide iTerm2 into multiple panes, each with its own session.\n\n-   **Search**: iTerm2 allows users to search through text and highlights occurrences.\n\n-   **Profiles**: Supports detailed profiles, each with its custom colors, fonts, window transparency, and key bindings.\n\n-   **Advanced Paste Features**: Offers a paste history and allows pasting with escape codes to avoid issues with unintended command executions.\n\n-   **Mouseless Copy**: iTerm2 lets you use keyboard shortcuts to select and copy text without needing the mouse.\n\n-   **Shell Integration**: iTerm2 can integrate with the shell to display badges, track command statuses, and more.\n\n-   **Trigger Support**: Executes user-defined actions based on text output to the terminal.\n:::\n:::\n\nEach of these terminal emulators offers unique features that cater to different needs and preferences, enhancing the user's command-line experience. Whether you need deep customization, minimal resource usage, or advanced functionalities like search and shell integration, there's a terminal emulator that fits the requirement.\n\n## [Recap]{style=\"font-size: 1.15em; font-weight: bold;\"}\n\nIn summary, the shell is the command interpreter that executes the commands, while the terminal is the application that allows you to interact with the shell.\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='default' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 0.95em;'}\n\n::: {style='font-size: 0.90em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}