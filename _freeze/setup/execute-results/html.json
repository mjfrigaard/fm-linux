{
  "hash": "9a06b94017740035044ec2ce1341a4d1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    \n---\n\n\n\n\n\n# Set-Ups {#sec-setups .unnumbered}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is under development. Thank you for your patience.\n  \n\n::: \n\n::::\n\n\n\n\n\nThis section of the book dives into the practical aspects of preparing your environment to work with Unix/Linux systems. It is designed to guide readers through various setup processes, catering to different preferences and requirements. We'll cover using Quarto documents to execute Bash commands, working directly on a macOS terminal, and setting up a virtual machine.\n\n##  Quarto {#sec-quarto}\n\n[Quarto](https://quarto.org/) is an '*open-source scientific and technical publishing system*' built on [Pandoc](https://pandoc.org/) that enables users to create dynamic and beautiful documents, reports, presentations, and dashboards. It is particularly useful for those looking to combine Unix/Linux command line operations with document creation, offering a way to embed executable code within documents. The next sections will guide you through writing YAML headers and Bash code chunks, two essential components when working with Quarto in a Unix/Linux context.\n\n\n\n\n\n\n\n:::: {.callout-note collapse='true' appearance='default' icon=false}\n\n## [Literate Programming]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.05em; color: #282b2d;'}\n\n\n\n> '*Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.*' - [Donald Knuth. Literate Programming (1984) in Literate Programming. CSLI, 1992, pg. 99.](http://www.literateprogramming.com/index.html)\n\n::: \n\n::::\n\n\n\n\n\n\n\n\n### YAML header {#sec-quarto-yaml}\n\n<code>@sec-yaml</code> is a lightweight markup language thatâ€™s easy to write and read. In Quarto, the `YAML` header is used to configure document properties such as the title, engine, output format, and more. It serves as the foundation for controlling how your Quarto document behaves and appears.\n\nQuarto documents are written in markdown and can include executable code in various programming languages, including Unix commands. The `YAML` header is placed between three dashes `---` at the top of each Quarto document to specify metadata and global options. \n\n```yaml\n---\ntitle: \"Using Bash\"\n---\n```\n\nTo run Bash commands, specify `knitr` in the `engine` field of in the `YAML` header of the Quarto file, and any additional key-value pairs:[^shell-reference]\n\n```yaml\n---\ntitle: \"Using Bash\"\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n---\n```\n\n[^shell-reference]: Read more about configuring shell code blocks in Quarto in the [documentation.](https://quarto.org/docs/computations/execution-options.html#shell-commands)\n\n### Bash Code Chunks {#sec-quarto-bash}\n\nIntroduced in 1989, Bash has become the default command-line interface or \"shell\" for most Linux distributions.[^bash-macos] We'll use Bash commands and scripts to preproceess data files, render Quarto documents, and automate other operations in the data analysis pipeline, from downloading and ingesting data to creating and deploying analysis outputs.  \n\n[^bash-macos]: Bash was the default command-line interface for Apple's macOS (which is Unix-based) until the transition to `zsh` as the default shell in macOS Catalina.\n\nOne of the powerful features of Quarto is the ability to integrate executable code chunks into Markdown documents.[^quarto-bash-book] You can create bash code chunks using the following syntax:\n\n```{{bash}}\necho \"foo\" \n```\n\n[^quarto-bash-book]: In fact, this entire book was created using Quarto and executable code chunks!\n\nBash code chunks allow you to include executable commands within your Quarto documents. You can also specify the code chunk options with the hash-pipe (`#|`):[^quarto-chunk-opts] \n\n```{{bash}}\n#| code-fold: show\n#| code-summary: 'show/hide echo'\necho \"foo\" \n```\n\nWhen the document is rendered, the narrative text is included with the output from the commnads.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"show\" code-summary=\"show/hide echo\"}\necho \"foo\"\n## foo\n```\n:::\n\n\n\n\n\n[^quarto-chunk-opts]: Consult the full list of code chunk options in the [Quarto documentation](https://quarto.org/docs/reference/cells/cells-knitr.html). \n\n This simplicity allows authors to focus on their content rather than formatting. \n \n### Code Chunk Isolation\n\nWhen incorporating Bash code chunks into Quarto documents, an essential detail to remember is the behavior of the working directory during file rendering. By default, Quarto sets the working directory to the location of the current document within the project.\n\nConsider the following scenario in a Quarto project:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# This code chunk displays the current working directory\npwd\n## /Users/mjfrigaard/projects/books/fm-unix\n```\n:::\n\n\n\n\n\nAlthough we can navigate to a different directory within a given code chunk:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data # Change the current working directory to 'data' \npwd # confirm the change\n## /Users/mjfrigaard/projects/books/fm-unix/data\n```\n:::\n\n\n\n\n\nIt's crucial to note that Quarto resets the working directory to the document's location for each new code chunk:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Verifying the working directory, which reverts to \npwd # the document's location for each new code chunk\n## /Users/mjfrigaard/projects/books/fm-unix\n```\n:::\n\n\n\n\n\nThis behavior is different than what we'd see in Posit Workbench's Terminal on my local machine:\n\n1. Assume the current working directory is `~/projects/` (as indicated by the blue highlighted area in the Terminal pane) \n\n![~/projects/](img/pwd-local-01.png){width='100%'}\n\n2. If we change my working directory with `..`, we are in the home directory `~`.\n\n![~/](img/pwd-local-02.png){width='100%'}\n\n3. When we check the current working directory again with `pwd`, we see the location has been *permanently* changed to `~`. \n\n![Still ~/](img/pwd-local-03.png){width='100%'}\n\nThis behavior can be frustrating, but it also means we'll start with a 'clean slate' in each new code chunk! \n\n## Terminal (macOS) {#sec-terminal}\n\nUsing macOS's Terminal to learn Unix/Linux offers a unique and powerful environment, but it comes with special considerations rooted in macOS's distinct architecture and its version of Unix. Here are key points to keep in mind:\n\n-   **Terminal Emulators**: The default Terminal app on macOS provides a solid interface to access the Unix command line, but there are other terminal emulators available (like [iTerm2](https://iterm2.com/)) that offer additional features such as split panes, search, and customization options.\n\n-   **Shells**: macOS has transitioned from using Bash as the default shell to Zsh since macOS Catalina. While both are Unix shells, they have some differences in features and configuration files (`~/.bash_profile` for Bash vs. `~/.zshrc` for Zsh).\n\n-   **Homebrew**: [Homebrew](https://brew.sh/) is an essential package manager for macOS, filling the gap for Unix/Linux software that isn't pre-installed on macOS. It allows users to easily install and manage additional Unix tools, GNU utilities, languages, and applications. Learning to use Homebrew will significantly expand the Unix/Linux tools at your disposal on a macOS system.\n\n-   **BSD vs. GNU Commands**:  macOS is based on Darwin, which incorporates elements from BSD Unix. Therefore, some of the command-line tools on macOS behave differently from their GNU counterparts found in Linux. For example, options and flags for commands like `ls`, `sed`, and `tar` may vary. This means that while the overarching principles remain the same, specific command syntax and options might require adjustments or the use of GNU versions of commands (installed via [Homebrew](https://brew.sh/), for instance).\n\n-   **Case Sensitivity**: By default, the macOS file system (APFS or HFS+) is **case-insensitive but case-preserving**. This behavior is different from most Linux file systems, which are *case-sensitive*. This can affect scripts and commands that rely on case distinctions for file and directory names.\n\n-   **Security and Permissions**: macOS has implemented increasingly stringent security measures, including the System Integrity Protection (SIP) and sandboxing mechanisms, which can restrict access to certain files and system operations. While these features enhance security, they can also limit what you can do via the Terminal. Understanding macOS's security model and permissions (such as using `sudo` wisely) is crucial.\n\n-   **Filesystem Hierarchy**: While the Unix filesystem hierarchy is preserved in macOS, there are macOS-specific directories and structures, such as `~/Library` for user-specific application support files and preferences. Understanding these macOS-specific elements is important when navigating and managing files via the Terminal.\n\n-   **Networking and Interoperability**: macOS integrates well with both Unix/Linux and Windows environments, supporting various network protocols and file sharing options out of the box. Commands like `ssh`, `scp`, and `smbutil` can be used for remote access and file transfers, making macOS a versatile platform for learning Unix/Linux networking basics.\n\n-   **Graphical Applications**: macOS allows Unix command-line tools to interact with its graphical user interface (GUI) applications in ways that are not typically available on other Unix systems. For instance, the `open` command can be used to open files or applications, and `osascript` can interact with AppleScript-enabled applications for automation.\n\n### Terminal Pane (Posit Workbench)\n\n![Terminal Pane in Posit Workbench](img/term-simple.png)\n\nLearning Unix/Linux on macOS provides a robust foundation with the added benefit of macOS-specific features and conveniences. However, it's essential to be aware of the differences and limitations inherent in macOS's implementation of Unix. Balancing the powerful capabilities of Unix with the peculiarities of macOS will allow you to make the most of your learning experience.\n\n## Virtual Machines {#sec-vms}\n\nVirtual machines (VMs) offer a flexible way to run Unix/Linux environments on top of your existing operating system, regardless of whether it's Windows, macOS, or another Linux distribution. This subsection explores the setup process for virtual machines, highlighting popular VM software like VirtualBox and VMware. It will guide readers through creating a new VM, installing a Unix/Linux distribution, configuring network settings, and optimizing performance. This part is essential for those looking to experiment with Unix/Linux systems in an isolated environment.\n\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='default' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 0.95em;'}\n\n::: {style='font-size: 0.90em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}