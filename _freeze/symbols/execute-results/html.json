{
  "hash": "d8a330d77fb6ef5e59ee6ed0724bfd92",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#'\n    \n---\n\n\n\n\n# Symbols {#sec-symbols}\n\n\n\n\n\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is under development. Thank you for your patience.\n  \n\n::: \n\n::::\n\n\n\n\nRegular expressions, or regex, are powerful tools for searching and manipulating text data. A regex is made up of special symbols that define specific patterns to be identified or transformed. The regular expressions are not the data themselves but rather a framework for locating or modifying the data. In this chapter, we will explore wildcards, regular expressions, and other special characters.\n\n## [Wildcards]{style=\"font-weight: bold;\"}  {#sec-wildcards}\n\nWildcards (also known as glob patterns) are primarily used in shell environments for matching filenames or filtering text in a less complex manner.\n\nWildcards are used in commands for matching filenames and paths (`ls`, `cp`, `mv`, `rm`, and more).\n\n### Asterisk: `*` {#sec-wc-asterisk}\n\n**Glob Patterns**: `*` is the wildcard for matching **zero or more characters**. Arguments can include wildcards, which the shell expands into a list of files or directories that match the pattern. For example, `*.txt` would match all files in the current directory ending with `.txt`.\n\n**Example** \n\n`ls *.md` lists all files in the current directory that end with `.md`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls *.md\n# README.md\n```\n:::\n\n\n\n\n### Question Mark: `?` {#sec-wc-question}\n\n`?` is the wildcard for matching **exactly one character**.\n\n**Example** \n\n`ls myfile?.txt` lists files like `myfile2.txt`, but not `myfile.txt` and `my file 3.txt`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls myfile?.txt\n# myfile2.txt\n```\n:::\n\n\n\n\n### Square brackets: `[]` {#sec-wc-square-brackets}\n\n`[abc]`: Matches any one character listed (a, b, or c).\n\n**Example** \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls [my]*.txt\n# my file 3.txt\n# myfile.txt\n# myfile2.txt\n```\n:::\n\n\n\n\n`[a-z]`: Matches any one character in the range (from a to z).\n\n**Example** \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls [m-n]*.txt\n# my file 3.txt\n# myfile.txt\n# myfile2.txt\n# newfile.txt\n```\n:::\n\n\n\n\n\n## [Regular Expressions]{style=\"font-weight: bold;\"} {#sec-regexp}\n\nRegular expressions (or the singular 'regex') are powerful tools for searching and manipulating text data. A regex is made up of special symbols that define specific patterns to be identified or transformed. \n\nRegular expressions operate on text--the sequence of characters that can include letters, digits, punctuation, and other character types. Text serves as the 'data' or 'medium' for which the patterns the regex describes are searched. \n\nRegular expressions are more complex than wildcards, and are typically used with tools like <code>@sec-grep</code> (global regular expression print), <code>@sec-sed</code> (stream editor), and <code>@sec-awk</code>.\n\n### Dot: `.`\n\n`.` matches any single character except a newline.\n\n**Examples**\n\nMatches lines containing \"password\" or similar patterns where any character stands between '`p`' and '`ssword`'.\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep \"p.ssword\" data/pwrds.csv\n# password,rank,strength,online_crack\n# password,1,8,6.91 years\n```\n:::\n\n\n\n\n\nReplaces \"`password`\" where any character is between '`p`' and '`ssword`' with \"`p@ssword`\".\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsed 's/p.ssword/p@ssword/' data/pwrds.csv | head -n2\n# p@ssword,rank,strength,online_crack\n# p@ssword,1,8,6.91 years\n```\n:::\n\n\n\n\nSelect records where \"`password`\" or similar patterns appear with any character between '`p`', '`ssw` and `rd`'.\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nawk '/p.ssw.rd/' data/pwrds.csv\n# password,rank,strength,online_crack\n# password,1,8,6.91 years\n# passw0rd,500,28,92.27 years\n```\n:::\n\n\n\n\n### Asterisk: `*`\n\n`*` matches zero or more of the preceding element.\n\n**Examples**\n\nWe can use `grep` to find lines where \"i\" is followed by zero or more \"l\"s (including none):\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep 'il*' data/wu_tang.txt\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n# Method Man \tClifford Smith\n# Ghostface Killah\tDennis Coles\n# U-God \tLamont Hawkins\n# Masta Killa \tJamel Irief\n# Cappadonna \tDarryl Hill\n# Ol Dirty Bastard \tRussell Tyrone Jones\n```\n:::\n\n\n\n\nWe can use `sed` to replace two or more `\"l\"`s with `11`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsed 's/lll*/11/g' data/wu_tang.txt\n# Member\tName\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n# Method Man \tClifford Smith\n# Raekwon the Chef \tCorey Woods\n# Ghostface Ki11ah\tDennis Coles\n# Inspectah Deck \tJason Hunter\n# U-God \tLamont Hawkins\n# Masta Ki11a \tJamel Irief\n# Cappadonna \tDarryl Hi11\n# Ol Dirty Bastard \tRusse11 Tyrone Jones\n```\n:::\n\n\n\n\nPrint lines that start with one or more `\"R\"`s\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nawk '/^ *R/' data/wu_tang.txt\n# RZA\tRobert Diggs\n# Raekwon the Chef \tCorey Woods\n```\n:::\n\n\n\n\n\n### Plus: `+`\n\n`+` matches one or more occurrences of the preceding element.\n\n**Examples**\n\nUse `grep` with extended regular expressions to find '`i`' followed by one or more '`l`'s:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep -E 'il+' data/wu_tang.txt\n# Ghostface Killah\tDennis Coles\n# Masta Killa \tJamel Irief\n# Cappadonna \tDarryl Hill\n```\n:::\n\n\n\n\nReplace one or more `\"a\"`s with the `@`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsed -E 's/a+/@/g' data/wu_tang.txt\n# Member\tN@me\n# RZA\tRobert Diggs\n# GZA\tG@ry Grice\n# Method M@n \tClifford Smith\n# R@ekwon the Chef \tCorey Woods\n# Ghostf@ce Kill@h\tDennis Coles\n# Inspect@h Deck \tJ@son Hunter\n# U-God \tL@mont H@wkins\n# M@st@ Kill@ \tJ@mel Irief\n# C@pp@donn@ \tD@rryl Hill\n# Ol Dirty B@st@rd \tRussell Tyrone Jones\n```\n:::\n\n\n\n\nThe `+` operator needs the `-E` option to enable extended regular expressions.\n\nPrint lines with text containing one or more `\"Z\"`s:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nawk '/Z+/' data/wu_tang.txt\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n```\n:::\n\n\n\n\n\n### Question Mark: `?`\n\n`?` makes the preceding element optional (matches zero or one occurrence).\n\n**Examples**\n\nUse `grep` with extended regular expressions to find lines with '`Killah`' or '`Killah`':\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep -E 'Kill?' data/wu_tang.txt\n# Ghostface Killah\tDennis Coles\n# Masta Killa \tJamel Irief\n```\n:::\n\n\n\n\n**sed:** Replace `Ghostface` with `Ghost Face`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsed -E 's/Ghostface?/Ghost Face/' data/wu_tang.txt\n# Member\tName\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n# Method Man \tClifford Smith\n# Raekwon the Chef \tCorey Woods\n# Ghost Face Killah\tDennis Coles\n# Inspectah Deck \tJason Hunter\n# U-God \tLamont Hawkins\n# Masta Killa \tJamel Irief\n# Cappadonna \tDarryl Hill\n# Ol Dirty Bastard \tRussell Tyrone Jones\n```\n:::\n\n\n\n\n**awk:** Print lines with one or more digits.\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nawk '/[0-9]+/' data/wu_tang.txt\n```\n:::\n\n\n\n\n### Character Set: `[abc]`\n\n`[abc]` matches any single character listed in the set.\n\n**Example**\n\nUse `grep` to find lines containing 'a', 'b', or 'c':\n\n```bash\ngrep '[abc]' filename.txt\n```\n\n### Caret: `^`\n\n`^` matches the start of a line.\n\n**Example**\n\nUse `grep` to find lines that start with 'start':\n\n```bash\ngrep '^start' filename.txt\n```\n\n### Dollar: `$`\n\n`$` matches the end of a line.\n\n**Example**\n\nUse `grep` to find lines that end with 'end':\n\n```bash\ngrep 'end$' filename.txt\n```\n\nThese patterns are extremely powerful in scripting and command-line operations for filtering and manipulating text data efficiently. Hereâ€™s how you might use them in combination across different tools:\n\n- **`sed` for substitution**: Replace 'foo' with 'bar' only if 'foo' appears at the beginning of a line:\n\n```bash\nsed 's/^foo/bar/' filename.txt\n```\n\n- **`awk` for selection**: Print lines where the first field matches 'start':\n\n```bash\nawk '/^start/ {print $0}' filename.txt\n```\n\n- **`perl` for advanced manipulation**: Increment numbers found at the end of each line:\n\n```bash\nperl -pe 's/(\\d+)$/ $1+1 /e' filename.txt\n```\n\n## [Special Characters]{style=\"font-weight: bold;\"}\n\n**Special Characters**: Characters such as spaces, quotes, and others have special meanings in the shell. They need to be treated carefully when used within arguments.\n\n### Braces: `{}` {#sec-braces}\n\n**Brace Expansion**: Similar to wildcards, brace expansion (`{}`) allows the creation of multiple text strings from a pattern containing braces. \n\n**Example**\n\n`cat wu_tang.{txt,csv}` \n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat data/wu_tang.{tsv,dat}\n# Member\tName\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n# Method Man\tClifford Smith\n# Raekwon the Chef\tCorey Woods\n# Ghostface Killah\tDennis Coles\n# Inspectah Deck\tJason Hunter\n# U-God\tLamont Hawkins\n# Masta Killa\tJamel Irief\n# Cappadonna\tDarryl Hill\n# Ol Dirty Bastard\tRussell Tyrone Jones\n# |Member           |Name                 |\n# |RZA              |Robert Diggs         |\n# |GZA              |Gary Grice           |\n# |Method Man       |Clifford Smith       |\n# |Raekwon the Chef |Corey Woods          |\n# |Ghostface Killah |Dennis Coles         |\n# |Inspectah Deck   |Jason Hunter         |\n# |U-God            |Lamont Hawkins       |\n# |Masta Killa      |Jamel Irief          |\n# |Cappadonna       |Darryl Hill          |\n# |Ol Dirty Bastard |Russell Tyrone Jones |\n```\n:::\n\n\n\n\nExpands into:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat data/wu_tang.tsv \ncat data/wu_tang.dat\n# Member\tName\n# RZA\tRobert Diggs\n# GZA\tGary Grice\n# Method Man\tClifford Smith\n# Raekwon the Chef\tCorey Woods\n# Ghostface Killah\tDennis Coles\n# Inspectah Deck\tJason Hunter\n# U-God\tLamont Hawkins\n# Masta Killa\tJamel Irief\n# Cappadonna\tDarryl Hill\n# Ol Dirty Bastard\tRussell Tyrone Jones\n# |Member           |Name                 |\n# |RZA              |Robert Diggs         |\n# |GZA              |Gary Grice           |\n# |Method Man       |Clifford Smith       |\n# |Raekwon the Chef |Corey Woods          |\n# |Ghostface Killah |Dennis Coles         |\n# |Inspectah Deck   |Jason Hunter         |\n# |U-God            |Lamont Hawkins       |\n# |Masta Killa      |Jamel Irief          |\n# |Cappadonna       |Darryl Hill          |\n# |Ol Dirty Bastard |Russell Tyrone Jones |\n```\n:::\n\n\n\n\n### Backslash: `\\` {#sec-backslash}\n\n`\\` escapes the following character, nullifying its special meaning\n\n**Example** \n\n`echo \"File name with spaces \\& special characters\"` prints the text with spaces and the ampersand:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"File name with spaces \\& special characters\"\n# File name with spaces & special characters\n```\n:::\n\n\n\n\n\n### Single quotes: `''` {#sec-single-quotes}\n\nSingle quotes (`' '`) treat every character literally, ignoring the special meaning of all characters.\n\n**Example** \n\n`echo '$HOME'` prints `$HOME`, not the path to the home directory:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho '$HOME'\n# $HOME\n```\n:::\n\n\n\n\n### Double quotes: `\"\"` {#sec-double-quotes}\n\nDouble quotes (`\" \"`) allow for the inclusion of special characters in an argument, except for the dollar sign (`$`), backticks (\\` \\`), and backslash (`\\`). \n\n**Example** \n\n`echo \"$HOME\"` prints the path to the home directory:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"$HOME\"\n#> /Users/username\n```\n:::\n\n\n\n\n### Tilde: `~` {#sec-tilde}\n\n`~` represents the home directory of the current user.\n\n**Example** \n\nList the items in the user's home directory:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls ~\n#> Applications\n#> Creative Cloud Files\n#> Desktop\n#> Documents\n#> Downloads\n#> Dropbox\n#> Fonts\n#> Library\n#> Movies\n#> Music\n#> Pictures\n#> Public\n#> R\n#> Themes\n```\n:::\n\n\n\n\n\n### Dollar Sign: `$` {#sec-dollar}\n\n`$` indicates a variable.\n\n**Example** \n\n`echo $PATH` prints the value of the `PATH` environment variable:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho $PATH\n```\n:::\n\n\n\n\n\n### Ampersand: `&` {#sec-ampersand}\n\n`&` runs a command in the background.\n\n**Example** \n\n`firefox &` opens Firefox in the background, allowing the terminal to be used for other commands.\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfirefox &\n```\n:::\n\n\n\n\n### Semicolon: `;` {#sec-semicolon}\n\n`;` separates multiple commands to be run in sequence.\n\n**Example** \n\n`cd data; ls` changes the directory to `data` and then lists its contents:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data; ls\n# ajperlis_epigrams.txt\n# music_vids.tsv\n# pwrds.csv\n# pwrds.tsv\n# roxanne.txt\n# roxanne_orig.txt\n# roxanne_rev.txt\n# trees.tsv\n# vg_hof.tsv\n# who-tb-data.tsv\n# who_tb_data.txt\n# wu_tang.csv\n# wu_tang.dat\n# wu_tang.tsv\n# wu_tang.txt\n```\n:::\n\n\n\n\n\n### Greater Than: `>` {#sec-gt}\n\n**Redirection operators**: `>` directs output to a file or a device. \n\n**Example** \n\n`echo \"This is my 2nd file\" > myfile2.txt` writes `\"This is my 2nd file\"` into `myfile2.txt`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"This is my 2nd file\" > myfile2.txt\n```\n:::\n\n\n\n\n### Less Than: `<` {#sec-lt}\n\n**Redirection operators**: `<` takes input from a file or a device.\n\n**Example** \n\nThen `wc < myfile2.txt` counts the words in `myfile2.txt`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwc < myfile2.txt\n#        1       5      20\n```\n:::\n\n\n\n\n\n### Parentheses: `()` {#sec-parens}\n\nParentheses can be used to group commands or for command substitution with `$( )`.\n\n**Example** \n\n`(cd /data; ls)` runs `ls` in `/data` without changing the current directory:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n(cd data; ls)\n# ajperlis_epigrams.txt\n# music_vids.tsv\n# pwrds.csv\n# pwrds.tsv\n# roxanne.txt\n# roxanne_orig.txt\n# roxanne_rev.txt\n# trees.tsv\n# vg_hof.tsv\n# who-tb-data.tsv\n# who_tb_data.txt\n# wu_tang.csv\n# wu_tang.dat\n# wu_tang.tsv\n# wu_tang.txt\n```\n:::\n\n\n\n\n`$(command)` uses the output of `command`.\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='default' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 0.95em;'}\n\n::: {style='font-size: 0.90em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}