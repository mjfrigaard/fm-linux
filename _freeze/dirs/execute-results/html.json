{
  "hash": "f5972a61a4c6531094dfb1186efd333c",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#'\n---\n\n\n\n\n\n# Directories {#sec-dirs}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon='false'}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is being revised. Thank you for your patience.\n\n::: \n\n::::\n\n\n\n\n\nWhen presented with a new map, the most important thing to find is your location on it. It's hard to know where you're going without knowing where you are. This chapter covers commands you'll use every day to get around in a Linux system.\n\n## [Navigate]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-nav-dirs}\n\n### `pwd`\n\n**<code>@sec-pwd</code>** (print working directory) tells you exactly where you are in the filesystem.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd \n# /Users/username/projects/books/fm-unix\n```\n:::\n\n\n\n\n\n[File paths]{style=\"font-size: 1.25em; font-weight: bold; font-style: italic;\"} \n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nThe output from `pwd` is the file path to our local working directory. A file path is a character string specifying the unique location of a file or directory within the hierarchical file system. File paths can be **absolute** (starting from the root  (`/`) directory) or **relative** (starting from the current (`.`) directory). \n\nIn Linux systems, the `~` represents the user's 'home' directory.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ~\npwd\n# /Users/username\n```\n:::\n\n\n\n\n\n\n### `tree`\n\nThe `tree` command will recursively print the directory structure of a file path in a 'tree-like' format, visually representing the hierarchy of files and directories.\n\nBelow is an example 'folder tree' for the current working directory returned from the `pwd` command above:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# /Users/ \n#   └─ username/ -> represented as '~'\n#        └─ project/ \n#             └─ books/ \n#                 └─ fm-unix/\n```\n:::\n\n\n\n\n\n\nThe output from `pwd` is an absolute file path, and **absolute file paths** do not change regardless of the current working directory. \n\n### `cd`\n\nMove from one directory to another with **<code>@sec-cd</code>** (change directory). For example, `cd data` takes you to the `data` folder *inside* our current working directory.  \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data\n```\n:::\n\n\n\n\n\nIn the command above, `data` is a relative file path. **Relative file paths** specify the location of a file *relative to the current working directory*.\n\n:::{layout=\"[50,50]\" layout-valign=\"top\"}\n\nIf we view our current directory with `tree` after changing it to `data`, we see the current location listed as `.`:\n\n``` sh\ncd data \ntree -d\n# .\n# └── raw\n# \n# 2 directories\n```\n\n:::\n\nIt's important to notice the difference between absolute and relative paths, because it makes it easier to navigate the operating system and manipulate files and folders.\n\nFor example, can use a relative file path to view the `report.txt` file in the `data` folder with `cat`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data\ncat report.txt\n# my important information\n```\n:::\n\n\n\n\n\n`data/report.txt` is the relative file path (i.e., relative to the current working directory), and it's meaning is based on the directory from which it is referenced.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n### `ls`\n\n**<code>@sec-ls</code>** (list) lists the files and folders in a given location. In `/bin`, `ls` would show you the software tools available:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd /bin # change location\nls # what's in here?\n# [\n# bash\n# cat\n# chmod\n# cp\n# csh\n# dash\n# date\n# dd\n# df\n# echo\n# ed\n# expr\n# hostname\n# kill\n# ksh\n# launchctl\n# link\n# ln\n# ls\n# mkdir\n# mv\n# pax\n# ps\n# pwd\n# realpath\n# rm\n# rmdir\n# sh\n# sleep\n# stty\n# sync\n# tcsh\n# test\n# unlink\n# wait4path\n# zsh\n```\n:::\n\n\n\n\n\n\n### `find`\n\n**<code>@sec-find</code>** can be used to locate files *or* directories using the `-type` and `-name` options. The example below looks in the current working directory (`.`) for a folder named `data`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfind . -type d -name data\n# ./data\n```\n:::\n\n\n\n\n\n## [Manage]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-manage-dirs}\n\nIn the Linux world, file and directory management is a fundamental skill. This chapter introduces some common commands that will allow you to create, copy, move, remove, and link files and directories. \n\n### `mkdir`\n\n**<code>@sec-mkdir</code>** (Make Directory) builds a new folder wherever you tell it to, like making a new folder in data for inputs (`data/in`) or outputs (`data/out`) \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir data/in\nmkdir data/out\n```\n:::\n\n\n\n\n\nConfirm with `tree -d` (the `-d` is for directories):\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data -d\n# data\n# ├── in\n# └── out\n# \n# 3 directories\n```\n:::\n\n\n\n\n\n### `cp`\n\n**<code>@sec-cp</code>** duplicates files or folders. The `cp` command is used to copy files or directories from one location to another. Imagine having a file (`binary_data.tsv`) on your root (`.`) directory that you want to copy to the `/data/in` folder; you could use `cp` to make a duplicate. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncp binary_data.tsv data/in/binary_data.tsv\n```\n:::\n\n\n\n\n\nConfirm with `tree`\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data/in\n# data/in\n# └── binary_data.tsv\n# \n# 1 directory, 1 file\n```\n:::\n\n\n\n\n\n### `mv`\n\n**<code>@sec-mv</code>**, short for move, moves files or directories from one location to another. We'll use it to move `data/binary_data.tsv` to `data/out/binary_data.tsv`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# move file\nmv data/in/binary_data.tsv data/out/binary_data.tsv \n```\n:::\n\n\n\n\n\nConfirm move with `tree`:[^tree-pattern]\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data -P *.tsv\n# data\n# ├── in\n# └── out\n#     └── binary_data.tsv\n# \n# 3 directories, 1 file\n```\n:::\n\n\n\n\n\n[^tree-pattern]: The `-P *.tsv` option for `tree` tells it to look in `data` for files or folders with a `.tsv` extension. We'll cover wildcards and patterns in the @sec-symbols-patterns chapter.\n\nIt can also be used for renaming files. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# rename file\nmv data/out/binary_data.tsv  data/out/bin_dat.tsv \n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# confirm rename \ntree data/out\n# data/out\n# └── bin_dat.tsv\n# \n# 1 directory, 1 file\n```\n:::\n\n\n\n\n\n`mv` is especially useful for organizing files and directories that are in the wrong place.\n\n### `rm`\n\nThe **<code>@sec-rm</code>** command stands for **remove** and is used to delete files or directories.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# remove doc folder\nrm data/out\n# rm: data/out: is a directory\n```\n:::\n\n\n\n\n\nBy default, it won't remove a directory without the `-R` or `-r` option.\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon='false'}\n\n## [Warning]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.05em; color: #282b2d;'}\n\n\n\n\nIt's important to note here that the command-line is not very forgiving. Using `rm` is a powerful action with significant consequences, as it permanently deletes files, akin to shredding documents. There's usually no easy way to recover deleted files unless you have a backup.\n\n> '*Linux is like a chainsaw. Chainsaws are powerful tools, and make many difficult tasks like cutting through thick logs quite easy. Unfortunately, this power comes with danger: chainsaws can cut just as easily through your leg.*' - Gary Bernhardt[^bernhardt]\n\n[^bernhardt]: As quoted in [Bioinformatics Data Skills: Reproducible and Robust Research with Open Source Tools (2015) by Vince Buffalo](https://bit.ly/3sVBSne).\n\n\n\n::: \n\n::::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# add option \nrm -R data/out\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## [Recap]{style=\"font-size: 1.05em; font-weight: bold;\"} \n\n\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='simple' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}