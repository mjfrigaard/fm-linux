{
  "hash": "1976d81404b5583729d2b1352ea5990a",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#'\n---\n\n\n\n\n\n# Directories {#sec-dirs}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is being revised. Thank you for your patience.\n\n::: \n\n::::\n\n\n\n\n\nWhen presented with a new map, the most important thing to find is your location on it. It's hard to know where you're going without knowing where you are. This chapter covers commands you'll use every day to get around in a Unix/Linux system.\n\n## [Navigate]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-nav-dirs}\n\n### `pwd`\n\n**`pwd` (Print Working Directory)** tells you exactly where you are in the filesystem.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd \n# /Users/mjfrigaard/projects/books/fm-unix\n```\n:::\n\n\n\n\n\n#### Paths\n\n**Absolute file paths** provide the complete directory path from the root directory to the specified file, and therefore do not change regardless of the current working directory. `pwd` returns an absolute file path:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n/Users/mjfrigaard/projects/books/fm-unix\n```\n:::\n\n\n\n\n\n**Relative file paths**, on the other hand, specify the location of a file relative to the current working directory, changing meaning based on the directory from which they are referenced.\n\nWe can use a relative file path to create a `report.txt` file in the `data` folder with the following text:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"my important information\" > data/report.txt\n```\n:::\n\n\n\n\n\nConfirm with `cat`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat data/report.txt\n# my important information\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n### `cd`\n\n **`cd` (Change Directory)** lets us move from one directory to a different directory. For example, `cd /bin` takes you to the `/bin` folder, the toolshed of software tools.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd /bin # change location\npwd # now where am I?\n# /bin\n```\n:::\n\n\n\n\n\n### `ls`\n\n**`ls` (List)** is like standing in one location, looking around, and seeing what files and folders are around you. In `/bin`, `ls` would show you the software tools available:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd /bin # change location\nls # what's in here?\n# [\n# bash\n# cat\n# chmod\n# cp\n# csh\n# dash\n# date\n# dd\n# df\n# echo\n# ed\n# expr\n# hostname\n# kill\n# ksh\n# launchctl\n# link\n# ln\n# ls\n# mkdir\n# mv\n# pax\n# ps\n# pwd\n# realpath\n# rm\n# rmdir\n# sh\n# sleep\n# stty\n# sync\n# tcsh\n# test\n# unlink\n# wait4path\n# zsh\n```\n:::\n\n\n\n\n\n\n### `find`\n\n`find` can be used to locate files *or* directories using the `-type` and `-name` options. The example below looks in the `data` directory for a `roxanne.txt` file:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfind data -type f -name roxanne.txt\n# data/roxanne.txt\n```\n:::\n\n\n\n\n\n### `locate`\n\n**`locate`** \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nlocate roxanne data | head -n3\n# /Users/mjfrigaard/projects/books/fm-unix/data/roxanne.txt\n# /Users/mjfrigaard/projects/books/fm-unix/data/roxanne_orig.txt\n# /Users/mjfrigaard/projects/books/fm-unix/data/roxanne_rev.txt\n```\n:::\n\n\n:::: {.callout-warning collapse='true' appearance='simple' icon=false}\n\n## [Updating `locate` database]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\n\nMake sure your `locate` database is up-to-date using one of the commands below if you've recently added or moved files to get accurate results:\n  \n``` sh\n# on linux\nsudo updatedb\n```\n\n``` sh\n# on macos\nsudo /usr/libexec/locate.updatedb\n```\n  \n\n\n::: \n\n::::\n\n\n\n\n\n## [Manage]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-manage-dirs}\n\nIn the Unix/Linux world, file and directory management is a fundamental skill. This chapter introduces some common commands that will allow you to create, copy, move, remove, and link files and directories. \n\n### `mkdir`\n\n**`mkdir` (Make Directory)** builds a new folder wherever you tell it to, like making a new folder in data for inputs (`data/in`) or outputs (`data/out`) \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir data/in\nmkdir data/out\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data -d\n# data\n# ├── in\n# └── out\n# \n# 3 directories\n```\n:::\n\n\n\n\n\n### `cp`\n\n**`cp` (Copy)** duplicates files or folders. The `cp` command is used to copy files or directories from one location to another. Imagine having a file (`bin.dat`) on your root (`.`) directory that you want to copy to the `/data/in` folder; you could use `cp` to make a duplicate. \n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ncp bin.dat data/in/bin.dat\n# confirm copy\nls data/in\n# bin.dat\n```\n:::\n\n\n\n\n\n### `mv`\n\n**`mv` (Move)**: `mv`, short for move, moves files or directories from one location to another.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# move file\nmv data/in/bin.dat data/out/bin.dat \n# confirm move \nls data/out \n# bin.dat\n```\n:::\n\n\n\n\n\nIt can also be used for renaming files. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# rename file\nmv data/out/bin.dat  data/out/binary_data.txt \n# confirm rename \nls data/out \n# binary_data.txt\n```\n:::\n\n\n\n\n\nThis command is especially useful for organizing files and directories that are in the wrong place.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data/out\n# data/out\n# └── binary_data.txt\n# \n# 1 directory, 1 file\n```\n:::\n\n\n\n\n\n\n### `rm`\n\n**`rm` (Remove)**: The `rm` command stands for **remove** and is used to delete files or directories.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# remove doc folder\nrm data/out\n# rm: data/out: is a directory\n```\n:::\n\n\n\n\n\nBy default, it won't remove a directory without the `-R` or `-r` option.\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon=false}\n\n## [Warning]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.05em; color: #282b2d;'}\n\n\n\n\nIt's important to note here that the command-line is not very forgiving. Using `rm` is a powerful action with significant consequences, as it permanently deletes files, akin to shredding documents. There's usually no easy way to recover deleted files unless you have a backup.\n\n> '*Unix is like a chainsaw. Chainsaws are powerful tools, and make many difficult tasks like cutting through thick logs quite easy. Unfortunately, this power comes with danger: chainsaws can cut just as easily through your leg.*' - Gary Bernhardt[^bernhardt]\n\n[^bernhardt]: As quoted in [Bioinformatics Data Skills: Reproducible and Robust Research with Open Source Tools (2015) by Vince Buffalo](https://bit.ly/3sVBSne).\n\n\n\n::: \n\n::::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# add option \nrm -R data/out\n```\n:::\n\n\n\n\n\n### `ln`\n\n**`ln` (Link)**: `ln` creates Links to files or directories, making them accessible from multiple locations without duplicating the actual content. It's like creating a shortcut on your desktop to a program you frequently use. There are two types of links: hard links and symbolic (soft) links. Symbolic links are more commonly used because they can link to directories and provide more flexibility.\n\n```bash\nln -s /path/to/original /path/to/link\n```\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## [Recap]{style=\"font-size: 1.05em; font-weight: bold;\"} \n\n\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='simple' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}