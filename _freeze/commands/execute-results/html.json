{
  "hash": "0bc0905fbf1e80de2844370c60d7a18a",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#>'\n---\n\n\n\n\n\n# Commands {#sec-commands}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is under development. Thank you for your patience.\n  \n\n::: \n\n::::\n\n\n\n\n\nCommands are the first part of a command line instruction, specifying the program or built-in functionality to be executed. In Unix/Linux, several commands can operate without any options or arguments, performing their basic functions in their simplest form.\n\n\nWe're going to start with a basic command: `date`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n#> Wed Apr 10 08:18:33 MST 2024\n```\n:::\n\n\n\n\n\n## REPL\n\nThe command `date` returns the current date and time. What we've just done is referred to as the [read–eval–print loop](https://www.computerhope.com/jargon/r/repl.htm), or REPL, and it's the underlying process of the command-line. The REPL in Bash exemplifies a powerful and flexible interface for interacting with the system, running commands, and developing scripts, providing both novice and experienced users with an efficient way to manage their computing environment.\n\nHere is how it works: \n\n### Read\n\nIn Bash, the \"Read\" step occurs when the shell waits for input from the user. This is typically represented by the shell prompt, where we can type commands. The prompt might display useful information, such as the current user (`username`), hostname (`hostname`), and working directory (`current_directory`), depending on its configuration:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$\n```\n:::\n\n\n\n\n\n### Eval\n\nOnce a command is entered, Bash \"evaluates\" it. This step involves parsing the command and its arguments, checking for syntax correctness, and then executing it. \n\nCommands can be simple, such as listing the current date and time, or complex scripts involving loops, conditionals, and functions.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$ date\n```\n:::\n\n\n\n\n\n### Print\n\nAfter evaluating the command, Bash \"prints\" the output or the result of the command execution to the screen (`stdout` or standard output) or another specified location. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#> Wed Apr 10 02:55:23 MST 2024\n```\n:::\n\n\n\n\n\nIf the command results in an error, the error message is displayed instead (typically on standard error).\n\n### Loop\n\nAfter executing a command and returning the output, Bash immediately returns to the \"read\" step, displaying the prompt and waiting for new user input. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$\nusername@hostname:current_directory$ date\n#> Wed Apr 10 02:55:23 MST 2024\nusername@hostname:current_directory$\n```\n:::\n\n\n\n\n\nThis cycle repeats indefinitely until the user exits the REPL environment, typically with an `exit` command or by pressing Ctrl+D.\n\n## Simple Commands \n\nIn Unix, several commands can operate without any options or arguments, performing their basic functions in their simplest form. Below are some of these commands:\n\n### `pwd` {#sec-pwd}\n\n`pwd` prints the current working directory. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd\n#> /Users/username/\n```\n:::\n\n\n\n\n\n\n### `ls` {#sec-ls}\n\n`ls` lists the contents of the current directory by default.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls \n#> Applications\n#> Library\n#> System\n#> Users\n#> Volumes\n#> bin\n#> cores\n#> dev\n#> etc\n#> home\n#> opt\n#> private\n#> sbin\n#> tmp\n#> usr\n#> var\n```\n:::\n\n\n\n\n\n\n### `date` {#sec-date}\n\n`date` displays the current date and time. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n#>  Wed Apr 10 03:39:52 MST 2024\n```\n:::\n\n\n\n\n\n\n### `uptime` {#sec-uptime}\n\n`uptime` shows how long the system has been running.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nuptime\n#>  3:39  up 11:23, 2 users, load averages: 3.82 3.21 3.00\n```\n:::\n\n\n\n\n\n\n### `who` {#sec-who}\n\n`who` shows who is logged on the system. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwho\n#>  username       console      Apr  9 03:20 \n#>  username       ttys000      Apr  9 03:42\n```\n:::\n\n\n\n\n\n`who` by itself, without options or arguments, lists the users currently logged into the system.\n\n\n### `clear` {#sec-clear}\n\n`clear` clears the terminal screen.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nclear\n```\n:::\n\n\n\n\n\n`clear` does its job without the need for additional input and doesn't print any return values.\n\n### `exit` {#sec-exit}\n\n`exit` exits the shell or your current session. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nexit\n```\n:::\n\n\n\n\n\n`exit` requires no arguments or options to execute this action, and doesn't print any return values.\n\n### `hostname` {#sec-hostname}\n\n`hostname` displays the system's network name.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nhostname\n#>  Users-MacBook-Pro-2.local\n```\n:::\n\n\n\n\n\n\n###  `yes` {#sec-yes}\n\n`yes` repeatedly outputs a string until killed. Without arguments, it defaults to outputting 'y'.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nyes\n```\n:::\n\n\n\n\n\n\nEach of these commands performs a specific and often utilized function within the Unix environment, embodying the Unix philosophy of doing one thing well.\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='default' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 0.95em;'}\n\n::: {style='font-size: 0.90em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}