{
  "hash": "c177af80983035c1259ab39a9b9dafa3",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#'\n---\n\n\n\n\n\n# Commands {#sec-commands}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is under development. Thank you for your patience.\n  \n\n::: \n\n::::\n\n\n\n\n\nCommands are the first part of a command line instruction, specifying the program or built-in functionality to be executed. In Unix/Linux, several commands can operate without any options or arguments, performing their basic functions in their simplest form.\n\nWe're going to start with a basic command: `date`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n# Sun Apr 28 12:28:20 MST 2024\n```\n:::\n\n\n\n\n\nThe command `date` returns the current date and time. What we've just done is referred to as the [read–eval–print loop](https://www.computerhope.com/jargon/r/repl.htm), or REPL, and it's the underlying process of the command-line. \n\n## [REPL]{style=\"font-size: 1.15em; font-weight: bold;\"}\n\nThe REPL in Bash exemplifies a powerful and flexible interface for interacting with the system, running commands, and developing scripts, providing both novice and experienced users with an efficient way to manage their computing environment.\n\nHere is how it works: \n\n### 1. Read\n\nIn Bash, the \"Read\" step occurs when the shell waits for input from the user. This is typically represented by the shell prompt, where we can type commands. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$\n```\n:::\n\n\n\n\n\nThe prompt might display useful information, such as the current user (`username`), hostname (`hostname`), and working directory (`current_directory`), depending on its configuration.\n\n### 2. Eval\n\nOnce a command is entered, Bash \"evaluates\" it. This step involves parsing the command and its arguments, checking for syntax correctness, and then executing it. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$ date\n```\n:::\n\n\n\n\n\nCommands can be simple, such as listing the current date and time, or complex scripts involving loops, conditionals, and functions.\n\n### 3. Print\n\nAfter evaluating the command, Bash \"prints\" the output or the result of the command execution to the screen (`stdout` or standard output) or another specified location. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#> Wed Apr 10 02:55:23 MST 2024\n```\n:::\n\n\n\n\n\nIf the command results in an error, the error message is displayed instead (typically on standard error).\n\n### Loop\n\nAfter executing a command and returning the output, Bash immediately returns to the \"read\" step, displaying the prompt and waiting for new user input. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nusername@hostname:current_directory$\nusername@hostname:current_directory$ date\n#> Wed Apr 10 02:55:23 MST 2024\nusername@hostname:current_directory$\n```\n:::\n\n\n\n\n\nThis cycle repeats indefinitely until the user exits the REPL environment, typically with an `exit` command or by pressing **<kbd>Ctrl</kbd>** + **<kbd>D</kbd>**.\n\n\n\n## [Basic commands]{style=\"font-size: 1.15em; font-weight: bold;\"} \n\nIn Unix, several commands can operate without any options or arguments, performing their basic functions in their simplest form. Below are some of these commands:\n\n### `who` \n\n`who` shows who is logged on the system. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwho\n# username       console      Apr 14 13:45 \n# username       ttys000      Apr 14 13:45 \n# username       ttys001      Apr 14 13:45 \n# username       ttys003      Apr 16 05:56\n```\n:::\n\n\n\n\n\n`who` by itself, without options or arguments, lists the users currently logged into the system.\n\n### `whoami` \n\n`whoami` shows the username of the user currently logged into the system. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwhoami\n# username\n```\n:::\n\n\n\n\n\n### `hostname` \n\n`hostname` displays the system's network name.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nhostname\n# Users-MacBook-Pro-2.local\n```\n:::\n\n\n\n\n\n### `cal` \n\n`cal` displays a calender of the current month.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncal\n#      April 2024       \n# Su Mo Tu We Th Fr Sa  \n#     1  2  3  4  5  6  \n#  7  8  9 10 11 12 13  \n# 14 15 16 17 18 19 20  \n# 21 22 23 24 25 26 27  \n# 28 29 30              \n# \n```\n:::\n\n\n\n\n\n### `uptime` \n\n`uptime` shows how long the system has been running.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nuptime\n# 11:39  up 15:05, 4 users, load averages: 3.85 3.08 2.93\n```\n:::\n\n\n\n\n\n### `clear` \n\n`clear` clears the terminal screen and doesn’t print any return values.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nclear\n```\n:::\n\n\n\n\n\n`clear` does its job without the need for additional input.\n\n### `exit` \n\n`exit` exits the shell or your current session. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nexit\n```\n:::\n\n\n\n\n\n`exit` requires no arguments or options to execute this action, and doesn't print any return values.\n\n###  `yes` \n\n`yes` repeatedly outputs a string until killed. Without arguments, it defaults to outputting 'y'.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nyes\n```\n:::\n\n\n\n\n\n**NOTE:** Use **<kbd>Ctrl</kbd>** + **<kbd>C</kbd>** to interrupt the `yes` command.\n\n## [Recap]{style=\"font-size: 1.15em; font-weight: bold;\"}\n\nEach of these commands performs a specific and often utilized function within the Unix environment, embodying the Unix philosophy of doing one thing well.\n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='default' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 0.95em;'}\n\n::: {style='font-size: 0.90em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-unix/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}