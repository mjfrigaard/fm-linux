---
engine: knitr
knitr:
  opts_chunk: 
    collapse: true
    comment: '#>'
    
---

# Regular Expressions {#sec-regex}

```{bash}
#| label: setup
#| include: false
whoami
```

```{r}
#| label: common
#| include: false
source("_common.R")
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r",
  look = "default", 
  hsize = "1.25", 
  size = "1.00", 
  header = "Caution", 
  fold = FALSE,
  contents = "This section is under development. Thank you for your patience.
  "
)
```

## Patterns


### Asterisk: `*` {#sec-asterisk}

**Glob Patterns**: `*` is the wildcard for matching **zero or more characters**. Arguments can include wildcards, which the shell expands into a list of files or directories that match the pattern. For example, `*.txt` would match all files in the current directory ending with `.txt`.

**Example** 

`ls *.md` lists all files in the current directory that end with `.md`:

```{bash}
ls *.md
```

### Question Mark: `?` {#sec-question}

`?` is the wildcard for matching **exactly one character**.

**Example** 

`ls myfile?.txt` lists files like `myfile2.txt`, but not `myfile.txt` and `my file 3.txt`:

```{bash}
ls myfile?.txt
```

### Braces: `{}` {#sec-braces}

**Brace Expansion**: Similar to wildcards, brace expansion (`{}`) allows the creation of multiple text strings from a pattern containing braces. 

**Example**

`cat wu_tang.{txt,csv}` 

```{bash}
cat data/wu_tang.{tsv,dat}
```

would expand into:

```{bash}
cat data/wu_tang.tsv 
cat data/wu_tang.dat
```

### Backslash: `\` {#sec-backslash}

`\` escapes the following character, nullifying its special meaning

**Example** 

`echo "File name with spaces \& special characters"` prints the text with spaces and the ampersand:

```{bash}
echo "File name with spaces \& special characters"
```

### Single quotes: `''` {#sec-single-quotes}

Single quotes (`' '`) treat every character literally, ignoring the special meaning of all characters.

**Example** 

`echo '$HOME'` prints `$HOME`, not the path to the home directory:

```{bash}
echo '$HOME'
```

### Double quotes: `""` {#sec-double-quotes}

Double quotes (`" "`) allow for the inclusion of special characters in an argument, except for the dollar sign (`$`), backticks (\` \`), and backslash (`\`). 

**Example** 

`echo "$HOME"` prints the path to the home directory:

```{bash}
#| eval: false
echo "$HOME"
#> /Users/username
```

## Special Characters

**Special Characters**: Characters such as spaces, quotes, and others have special meanings in the shell. They need to be treated carefully when used within arguments.

### Tilde: `~` {#sec-tilde}

`~` represents the home directory of the current user.

**Example** 

List the items in the user's home directory:

```{bash}
#| eval: false
ls ~
#> Applications
#> Creative Cloud Files
#> Desktop
#> Documents
#> Downloads
#> Dropbox
#> Fonts
#> Library
#> Movies
#> Music
#> Pictures
#> Public
#> R
#> Themes
```


### Dollar Sign: `$` {#sec-dollar}

`$` indicates a variable.

**Example** 

`echo $PATH` prints the value of the `PATH` environment variable:

```{bash}
#| eval: false
echo $PATH
```


### Ampersand: `&` {#sec-ampersand}

`&` runs a command in the background.

**Example** 

`firefox &` opens Firefox in the background, allowing the terminal to be used for other commands.

```{bash}
#| eval: false
firefox &
```

### Semicolon: `;` {#sec-semicolon}

`;` separates multiple commands to be run in sequence.

**Example** 

`cd data; ls` changes the directory to `data` and then lists its contents:

```{bash}
cd data; ls
```


### Greater Than: `>` {#sec-gt}

**Redirection operators**: `>` directs output to a file or a device. 

**Example** 

`echo "This is my 2nd file" > myfile2.txt` writes `"This is my 2nd file"` into `myfile2.txt`:

```{bash}
echo "This is my 2nd file" > myfile2.txt
```

### Less Than: `<` {#sec-lt}

**Redirection operators**: `<` takes input from a file or a device.

**Example** 

Then `wc < myfile2.txt` counts the words in `myfile2.txt`:

```{bash}
wc < myfile2.txt
```


### Parentheses: `()` {#sec-parens}

Parentheses can be used to group commands or for command substitution with `$( )`.

**Example** 

`(cd /var; ls)` runs `ls in /var` without changing the current directory:

```{bash}
(cd data; ls)
```

`$(command)` uses the output of `command`.

```{r}
#| label: git_contrib_box
#| echo: false
#| results: asis
#| eval: true
git_contrib_box()
```